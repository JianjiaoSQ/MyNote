# **CONTENT**
<!-- TOC -->

- [**CONTENT**](#content)
  - [数据模型](#数据模型)
  - [主键与外键](#主键与外键)
  - [事务？](#事务)
  - [ACID？](#acid)
    - [1. 原子性（Atomicity）](#1-原子性atomicity)
    - [2. 一致性（Consistency）](#2-一致性consistency)
    - [3. 隔离性（Isolation）](#3-隔离性isolation)
    - [4. 持久性（Durability）](#4-持久性durability)
    - [补充](#补充)
  - [隔离级别？](#隔离级别)
    - [未提交读（READ UNCOMMITTED）](#未提交读read-uncommitted)
    - [提交读（READ COMMITTED）](#提交读read-committed)
    - [可重复读（REPEATABLE READ）](#可重复读repeatable-read)
    - [可串行化（SERIALIZABLE）](#可串行化serializable)
  - [并发一致性问题？](#并发一致性问题)
    - [丢失修改](#丢失修改)
    - [读脏数据](#读脏数据)
    - [不可重复读](#不可重复读)
    - [幻影读](#幻影读)
    - [原因](#原因)
  - [隔离级别解决的并发一致性问题](#隔离级别解决的并发一致性问题)
  - [封锁？](#封锁)
    - [封锁粒度](#封锁粒度)
    - [读写锁-行锁](#读写锁-行锁)
    - [意向锁-表锁](#意向锁-表锁)
  - [存储引擎](#存储引擎)
    - [InnoDB](#innodb)
    - [MyISAM](#myisam)
    - [比较](#比较)
  - [索引？](#索引)
    - [实现方法](#实现方法)
  - [聚簇索引与非聚簇索引？](#聚簇索引与非聚簇索引)
  - [B树、B+树、红黑树等在构造索引中的比较](#b树b树红黑树等在构造索引中的比较)
  - [关系数据库中的异常？](#关系数据库中的异常)
  - [范式？](#范式)
    - [1. 第一范式 (1NF)](#1-第一范式-1nf)
    - [2. 第二范式 (2NF)](#2-第二范式-2nf)
    - [3. 第三范式 (3NF)](#3-第三范式-3nf)
  - [视图？](#视图)
  - [MVCC？](#mvcc)
    - [基本思想](#基本思想)
    - [版本链？](#版本链)
    - [undo 日志？](#undo-日志)
    - [Read View ()](#read-view-)
  - [分库分表？](#分库分表)
  - [select 加锁问题](#select-加锁问题)
  - [Next-Key Locks](#next-key-locks)
    - [Record Locks](#record-locks)
    - [Gap Locks](#gap-locks)
    - [Next-Key Locks](#next-key-locks-1)

<!-- /TOC -->

---
## 数据模型

**数据库系统的核心和基础是数据模型**。一般来说，数据模型是严格定义的一组概念的集合。这些概念精确地描述了系统的静态特征、动态特征和完整性约束条件。因此**数据模型一般由数据结构、数据操作和完整性约束三部分组成**

1. **数据结构**：存储在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系
2. **数据操作**：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则
3. **完整性约束**：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性

根据模型应用目的的不同，数据模型分为2类：

* 第一类
    - 1）**概念模型**：也称为信息模型。它是按用户的观点来对数据和信息建模，主要用于数据库设计
* 第二类
    - 2）**逻辑模型**：主要包括层次模型、网状模型、**关系模型**、面向对象模型和对象关系模型等
    - 3）**物理模型**：是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的
    
**关系模型是目前最重要的一种数据类型**。关系数据库系统采用关系模型作为数据的组织方式

* 关系模型中数据的逻辑结构是一张**二维表**，或者说关系的数据结构就是一张表
* 关系数据模型的数据操作主要包含**查询**、**插入**、**删除**和**更新数据**
* 关系模型的完整性约束条件包含三大类：**实体完整性**、**参照完整性**和**用户自定义的完整性**
    - 关系模型的**实体完整性规则**：若属性（指一个或一组属性）A是基本关系R的主属性，则A不能取空值（由此规则可得一直接结论：主键不能为空）
    - 关系模型的**参照完整性规则**：若属性（或属性组）F是某基本关系R的外键，且它与基本关系R1的主键相对应，则对于R中，每个F上的值或为空值或者等于R1中的主键值

---
## 主键与外键

* **候选码**：关系（二维表）中能唯一标识一个元组的属性组
* **主键**：如果一张表有多个候选码，则选定其中一个为主键
* **外键**：如果关系模式R中的某属性集不是R的主键，而是另一个关系R1的主键，则该属性集是关系模式R的外键。外键表示了两个关系（表）之间的联系。以另一个关系的外键作主键的表被称为主表，具有此外键的表被称为主表的从表
* **主属性与非主属性**：候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性

---
## 事务？
* 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。
* 事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。

---
## ACID？
### 1. 原子性（Atomicity）

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

* 回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

### 2. 一致性（Consistency）

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

### 3. 隔离性（Isolation）

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

### 4. 持久性（Durability）

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

* 系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

### 补充

这几种特性并不是平级的关系：
- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

---
## 隔离级别？
### 未提交读（READ UNCOMMITTED）

事务中的修改，即使没有提交，对其它事务也是可见的。

最低隔离级别，所以所有的并发事务问题都有可能发生；脏读，不可重复读，幻读；

### 提交读（READ COMMITTED）

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可以解决脏读问题；

### 可重复读（REPEATABLE READ）

保证在同一个事务中多次读取同一数据的结果是一样的。

可以解决脏读，不可重复读；

### 可串行化（SERIALIZABLE）

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。


---
## 并发一致性问题？
### 丢失修改
丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改并提交生效，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

### 读脏数据
读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T<sub>1</sub> 修改一个数据但未提交，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。

### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

> 同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果；

### 幻影读

幻读本质上也属于不可重复读的情况，T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

> 幻读就是事务A不存在某数据，查询不成功；在事务A未结束之前，事务B又插入了这个数据并提交，然后事务A查询不成功，且插入数据也不成功，这个数据就像虚幻存在一样，这就是“幻读”；

### 原因
产生并发不一致性问题的主要原因是`破坏了事务的隔离性`，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

---
## 隔离级别解决的并发一致性问题

<center>

||脏读|不可重复读|幻读|
:--:|:--:|:--:|:--:|
未提交读|×|×|×|
提交读|√|×|×|
可重复读|√|√|×|
可串行化|√|√|√|

</center>

---
## 封锁？
### 封锁粒度

MySQL 中提供了两种封锁粒度：行级锁以及表级锁。

InnoDB引擎支持行锁和表锁，而 MyISAM 支持表锁；

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。

在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。

兼容性：

<center>

||S|X|
|--|--|--|
|**S**|√|×|
|**X**|×|×|

</center>

### 读写锁-行锁
- 共享锁（Shared），简写为 S 锁，又称读锁。
- 互斥锁（Exclusive），简写为 X 锁，又称写锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

### 意向锁-表锁

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

兼容性：

<center>

||S|X|IS|IX|
|--|--|--|--|--|
|**S**|√|×|√|×|
|**X**|×|×|×|×|
|IS|√|×|√|√|
|IX|×|×|√|√|

</center>

解释如下：

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T<sub>1</sub> 想要对数据行 R<sub>1</sub> 加 X 锁，事务 T<sub>2</sub> 想要对同一个表的数据行 R<sub>2</sub> 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

---
## 存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

> 关于热备份？[:notebook:](https://blog.51cto.com/u_10433221/1949505)

### MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。

---
## 索引？
**索引** 是对数据库中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息

为表设置索引的好处与坏处：

* 好处
    - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
    - 可以大大加快数据的检索速度（创建索引的主要原因）
    - 在使用分组（group by）和排序（order by）子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
    - 可以加速表和表之间的连接，特别是在实现数据的参照完整性方面特别有意义
* 坏处
    - 一是增加了数据库的存储空间
    - 二是插入和删除数据时要花费较多时间（因为索引也要随之变动）

索引是建立在数据库表中的某些列的上面。在创建索引时，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引：

* 一般来说，应该在这些列上创建索引
    - 1）在经常需要搜索的列上创建索引，可以加快搜索的速度
    - 2）在作为主键的列上创建索引，强制该列的唯一性和组织表中数据的排列结构
    - 3）在经常用在连接的列上创建索引，这些列主要是一些外键，可以加快连接的速度
    - 4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的
    - 5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
    - 6）在经常使用在`WHERE`子句中的列上创建索引，加快条件的判断速度
* 一般来说，不应该创建索引的这些列具有下列特点
    - 1）那些在查询中很少使用的列不应该创建索引。很少使用故而即使创建索引也不会带来很大性能提升。索引又会带来空间和维护上的负担
    - 2）只有很少数据值的列也不应该创建索引。如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引并不能明显加快检索速度
    - 3）那些定义为text和bit等数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少，不利于使用索引
    - 4）当修改操作远远大于检索操作时，不应该创建索引。因为修改性能和检索性能互相矛盾。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改的性能，降低检索的性能

### 实现方法
* 一般分为B+树索引和哈希索引。
* B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。
* 哈希索引：通过对key进行hash(crc/MD5/sha1/sha256...)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1/256码都较长不太适合作为hash函数。默认无序。

## 聚簇索引与非聚簇索引？

[:notebook:](https://blog.csdn.net/baidu_15952103/article/details/109234605?utm_source=app&app_version=4.7.1&code=app_1562916241&uLinkId=usr1mkqgl919blen)

索引从类型上可以分为 **B+树索引** 和 **哈希索引**；
索引从数据存储方式上可以分为 **聚簇索引** 和 **非聚簇索引**；

聚簇索引：每个InnoDB表都需要一个聚簇索引，聚簇索引可以帮助表优化增删改查操作；

InnoDB通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引；当表有了聚簇索引，表的数据行都存放在索引树的叶子页中；

非聚簇索引：又称为二级索引；二级索引的叶子节点存储的不是指向行的物理指针，而是行的主键值；当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后通过主键去聚簇索引中查找数据行；两次B-Tree查找；


**为什么有了B+树索引还要hash索引？**

* B+树默认有序，hash默认无序，所以哈希索引无法用于排序；
* 哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);
* 哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；
* 底层实现结构不同：B+树是非线性结构，hash桶是线性结构。
* 对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。

---
## B树、B+树、红黑树等在构造索引中的比较

> 参考文献：http://blog.codinglabs.org/articles/theory-of-mysql-index.html

B树：
1. 每个非叶子节点由n-1个key和n个指针组成，其中d <= n <= 2d（d表示出度）；
2. 每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null；
3. 所有叶节点具有相同的深度，等于树高h；
4. key和指针互相间隔，节点两端是指针。
5. 一个节点中的key从左到右非递减排列。

B+树：B+树是B树的变种；
1. 每个节点的指针上限为2d而不是2d+1；
2. 内节点不存储data，只存储key；叶子节点不存储指针；
3. 在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree；提高区间访问的性能；

由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。



---
## 关系数据库中的异常？
以下的学生课程关系的函数依赖为 {Sno, Cname} -\> {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 |
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |

不符合范式的关系，会产生很多异常，主要有以下四种异常：

- 冗余数据：例如 `学生-2` 出现了两次。
- 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 `课程-1` 需要删除第一行和第三行，那么 `学生-1` 的信息就会丢失。
- 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。

---
## 范式？
范式理论是为了解决以上提到四种异常。

高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

### 1. 第一范式 (1NF)

属性不可分。

### 2. 第二范式 (2NF)

每个非主属性完全函数依赖于键码。

可以通过分解来满足。

<font size=4>  **分解前**  </font><br>

| Sno | Sname | Sdept | Mname | Cname | Grade |
| :---: | :---: | :---: | :---: | :---: |:---:|
| 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 |
| 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 |
| 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |

以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname
- Sno, Cname-\> Grade

Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。

Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。

<font size=4>  **分解后**  </font><br>

关系-1

| Sno | Sname | Sdept | Mname |
| :---: | :---: | :---: | :---: |
| 1 | 学生-1 | 学院-1 | 院长-1 |
| 2 | 学生-2 | 学院-2 | 院长-2 |
| 3 | 学生-3 | 学院-2 | 院长-2 |

有以下函数依赖：

- Sno -\> Sname, Sdept
- Sdept -\> Mname

关系-2

| Sno | Cname | Grade |
| :---: | :---: |:---:|
| 1 | 课程-1 | 90 |
| 2 | 课程-2 | 80 |
| 2 | 课程-1 | 100 |
| 3 | 课程-2 | 95 |

有以下函数依赖：

- Sno, Cname -\>  Grade

### 3. 第三范式 (3NF)

非主属性不传递函数依赖于键码。

上面的 关系-1 中存在以下传递函数依赖：

- Sno -\> Sdept -\> Mname

可以进行以下分解：

关系-11

| Sno | Sname | Sdept |
| :---: | :---: | :---: |
| 1 | 学生-1 | 学院-1 |
| 2 | 学生-2 | 学院-2 |
| 3 | 学生-3 | 学院-2 |

关系-12

| Sdept | Mname |
| :---: | :---: |
| 学院-1 | 院长-1 |
| 学院-2 | 院长-2 |

---
## 视图？
**视图** 是从一个或几个基本表（或试图）导出的表。与基本表不同，它是一个虚表

数据库中只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化时，视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化

视图一经定义，就可以和基本表一样被查询、删除

---
## [MVCC？](https://www.php.cn/mysql-tutorials-460111.html)
全称 Multi-Version Concurrency Control，即多版本并发控制，主要是为了提高数据库的并发性能。

MVCC 是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现`提交读` 和 `可重复读`这两种隔离级别。而`未提交读`隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。`可串行化`隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。

### 基本思想
在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。

`脏读` 和 `不可重复读` 最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。

读操作只读取该事务开始前的数据库快照。

**当前读：** 它读取的数据库记录，都是当前最新的版本，会对当前读取的数据进行加锁，防止其他事务修改数据。是悲观锁的一种操作。

如下操作都是当前读：
```
select lock in share mode (共享锁)
select for update (排他锁)
update (排他锁)
insert (排他锁)
delete (排他锁)
串行化事务隔离级别
```

**快照读：** 快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。

如下操作是快照读：

不加锁的select操作（注：事务级别不是串行化）

**实现原理：** 主要是版本链，undo日志 ，Read View 来实现；

### 版本链？
- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

### undo 日志？
MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID  写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

### Read View ()
MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/> </div><br>

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID \< TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。

- TRX_ID \> TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN \<= TRX_ID \<= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID  在 TRX_IDs  列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR  找到下一个快照，再进行上面的判断。

---
## 分库分表？

目的：为了解决由于数据量过大而导致数据库性能降低的问题，将原来的数据库拆分为若干个数据库组成，将数据大表拆分为若干个数据表组成，使得单一数据库和数据表的数据量变小，从而达到提升数据库性能的目的；

方法：垂直分表、垂直分库、水平分表、水平分库；

**垂直分表：** 按字段拆分为多个表，每个表存储一部分字段；

**垂直分库：** 按照业务将表进行分类，分布到不同的数据库上面，每个库部署在不同服务器上，实现“专库专用”；

**水平分库：** 将同一类表中的数据按照一定的规则拆分到不同的数据库中，每个库可以放在不同的服务器上；这样解决了单库大数据、高并发的瓶颈；

**水平分表：** 在同一数据库中，按照一定规则将一个大表拆分为多个表；

## select 加锁问题

[select 加锁问题](https://www.cnblogs.com/rjzheng/p/9950951.html)

## Next-Key Locks

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。

### Record Locks

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。

### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```sql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

### Next-Key Locks

它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```
