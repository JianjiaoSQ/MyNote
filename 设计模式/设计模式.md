# **Design-Patterns**

<!-- TOC -->

- [**Design-Patterns**](#design-patterns)
  - [介绍](#介绍)
  - [单例模式](#单例模式)
    - [懒汉式](#懒汉式)
    - [饿汉式](#饿汉式)
  - [工厂方法模式](#工厂方法模式)
  - [建造者模式](#建造者模式)
  - [代理模式](#代理模式)
  - [策略模式](#策略模式)
  - [模板方法模式](#模板方法模式)

<!-- /TOC -->

<br>

----
## 介绍
**设计模式** 是软件设计中常见问题的典型解决方案。
设计模式分为三类：创建型模式、结构型模式、行为模式；

**创建型模式：** 对象实例化的模式，创建型模式用于解耦对象的实例化过程。

* 单例模式：某个类智能有一个实例，提供一个全局的访问点。
* 工厂模式：一个工厂类根据传入的参量决定创建出哪一种产品类的实例。
* 抽象工厂模式：创建相关或依赖对象的家族，而无需明确指定具体类。
* 建造者模式：封装一个复杂对象的创建过程，并可以按步骤构造。
* 原型模式：通过复制现有的实例来创建新的实例。

**结构型模式：** 把类或对象结合在一起形成一个更大的结构。

* 装饰器模式：动态的给对象添加新的功能。
* 代理模式：为其它对象提供一个代理以便控制这个对象的访问。
* 桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。
* 适配器模式：将一个类的方法接口转换成客户希望的另一个接口。
* 组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。
* 外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。
* 享元模式：通过共享技术来有效的支持大量细粒度的对象。

**行为模式：** 类和对象如何交互，及划分责任和算法。

* 策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。
* 模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。
* 命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。
* 迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。
* 观察者模式：对象间的一对多的依赖关系。
* 仲裁者模式：用一个中介对象来封装一系列的对象交互。
* 备忘录模式：在不破坏封装的前提下，保持对象的内部状态。
* 解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
* 状态模式：允许一个对象在其对象内部状态改变时改变它的行为。
* 责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。
* 访问者模式：不改变数据结构的前提下，增加作用于一组对象元素的新功能。

---

<center> <h2>Reference</h2> </center> 

[ **:notebook:**](https://refactoringguru.cn/design-patterns)

---
## 单例模式
保证一个类仅有一个实例，并提供一个访问它的全局访问点；
### 懒汉式
* 线程不安全
  - 单线程安全，多线程不安全；当多个线程同时调用 `getInatance()`, 同时构造一个实例返回给 `Inatance`;
```cpp
class Singleton {
private:
    Singleton(){}
    static Singleton* Instance;
public:
    static Singleton* getInstance() {
        if(Instance == NULL) Instance = new Singleton();
        return Instance; 
    }
};
```
* 双重检查锁
```cpp
class Singleton {
private:
    Singleton(){}
    static Singleton* Instance;
public:
    static Singleton* getInstance() {
        if(Instance == NULL) {
            Lock();
            if(Instance == NULL) Instance = new Singleton();
            unLock();
        }
        return Instance; 
    }
};
```
### 饿汉式
* 饿汉式时线程安全的；
```cpp
class Singleton {
private:
    Singleton(){}
public:
    static Singleton* getInstance() {
        static Singleton Instance;
        return &Instance;
    }
};
```

---
## 工厂方法模式
定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行；

---
## 建造者模式
建造者模式唯一区别于工厂模式的是针对复杂对象的创建。也就是说，如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，就可以考虑使用建造者模式。

建造者模式主要适用于以下应用场景：
* 相同的方法，不同的执行顺序，产生不同的结果。
* 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同。
* 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用。
* 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。

建造者模式和工厂模式的区别？
* 建造者模式更加注重方法的调用顺序，工厂模式注重创建对象。
* 创建对象的力度不同，建造者模式创建复杂的对象，由各种复杂的部件组成，工厂模式创建出来的对象都一样
* 关注重点不一样，工厂模式只需要把对象创建出来就可以了，而建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。
* 建造者模式根据建造过程中的顺序不一样，最终对象部件组成也不一样。

---
## 代理模式

---
## 策略模式
定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。


---
## 模板方法模式