# Effective C++ 

- [Effective C++](#effective-c)
  - [条款02-尽量以 const、enum、inline 替换\#define](#条款02-尽量以-constenuminline-替换define)
    - [const 替换 \#define](#const-替换-define)
  - [条款03-尽可能使用 const](#条款03-尽可能使用-const)
  - [条款04-确定对象被使用前已被初始化](#条款04-确定对象被使用前已被初始化)
  - [条款05-了解C++默默编写并调用了哪些函数](#条款05-了解c默默编写并调用了哪些函数)
  - [条款06-若不想使用编译器自动生成的函数，就该明确拒绝](#条款06-若不想使用编译器自动生成的函数就该明确拒绝)
  - [条款07-为多态基类声明 virtual 析构函数](#条款07-为多态基类声明-virtual-析构函数)
  - [条款08-别让异常逃离析构函数](#条款08-别让异常逃离析构函数)
  - [条款09-绝不在构造和析构过程中调用 virtual 函数](#条款09-绝不在构造和析构过程中调用-virtual-函数)
  - [条款10-令 operator= 返回一个 reference to \*this](#条款10-令-operator-返回一个-reference-to-this)
  - [条款11-在 operator= 中处理“自我赋值”](#条款11-在-operator-中处理自我赋值)
  - [条款12-复制对象时勿忘其每一个成分](#条款12-复制对象时勿忘其每一个成分)
  - [条款13-以对象管理资源](#条款13-以对象管理资源)
  - [条款14-资源管理类中小心 copying 行为](#条款14-资源管理类中小心-copying-行为)
  - [条款15-在资源管理类提供对原始资源的访问](#条款15-在资源管理类提供对原始资源的访问)
  - [条款16-成对使用 new 和 delete 时要采用相同形式](#条款16-成对使用-new-和-delete-时要采用相同形式)
  - [条款17-以独立语句将 newed 对象置入智能指针](#条款17-以独立语句将-newed-对象置入智能指针)
  - [条款18-让接口容易被正确使用，不易被误用](#条款18-让接口容易被正确使用不易被误用)
  - [条款19-设计 class 犹如设计 type](#条款19-设计-class-犹如设计-type)
  - [条款20-宁以 pass-by-reference-to-const 替换 pass-by-value](#条款20-宁以-pass-by-reference-to-const-替换-pass-by-value)



---
## 条款02-尽量以 const、enum、inline 替换\#define
### const 替换 \#define
```c++
#define ASPECT_RATIO 1.653
替换为：
const double AspectRatio = 1.653
```
* 更容易调试
* 较小量的码

## 条款03-尽可能使用 const

## 条款04-确定对象被使用前已被初始化

## 条款05-了解C++默默编写并调用了哪些函数

## 条款06-若不想使用编译器自动生成的函数，就该明确拒绝

## 条款07-为多态基类声明 virtual 析构函数

## 条款08-别让异常逃离析构函数

## 条款09-绝不在构造和析构过程中调用 virtual 函数

## 条款10-令 operator= 返回一个 reference to \*this

## 条款11-在 operator= 中处理“自我赋值”

## 条款12-复制对象时勿忘其每一个成分

## 条款13-以对象管理资源

## 条款14-资源管理类中小心 copying 行为

## 条款15-在资源管理类提供对原始资源的访问

## 条款16-成对使用 new 和 delete 时要采用相同形式

## 条款17-以独立语句将 newed 对象置入智能指针

## 条款18-让接口容易被正确使用，不易被误用

## 条款19-设计 class 犹如设计 type

## 条款20-宁以 pass-by-reference-to-const 替换 pass-by-value

